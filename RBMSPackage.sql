set serveroutput on

/**
* RBMSPackage is a package and
* below is the package specification 
*/

create or replace package RBMSPackage as
    type my_cursor is ref cursor;

    function retrieveEmployees
    return my_cursor;

    function retrieveCustomers
    return my_cursor;

    function retrieveProducts
    return my_cursor;

    function retrieveProdDiscnts
    return my_cursor;

    function retrievePurchases
    return my_cursor;

    function retrieveLogs
    return my_cursor;

    function monthlySaleActvities(employeeId in employees.eid%type)
    return my_cursor;

    PROCEDURE add_employee(e_id IN employees.eid%type, e_name IN employees.name%type,
          e_telephone IN employees.telephone#%type, e_email IN employees.email%type);

    PROCEDURE add_purchase(e_id in purchases.eid%type, p_id in purchases.pid%type,
          c_id in purchases.cid%type, pur_qty in purchases.quantity%type, pur_unit_price purchases.unit_price%type);
    
     end;
    /

/**
* My package RBMSPackage body start from here
* It as all the functions to retrive each table, add_employee(), add_purchase();
*/
    create or replace package body RBMSPackage as 
      
      function retrieveEmployees 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from employees;
           return my_ref;
      end;

      function retrieveCustomers 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from customers;
           return my_ref;
      end;

      function retrieveProducts 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from products;
           return my_ref;
      end;

      function retrieveProdDiscnts 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from prod_discnt;
           return my_ref;
      end;

      function retrievePurchases 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from purchases;
           return my_ref;
      end;

      function retrieveLogs 
      return my_cursor is
      my_ref my_cursor;
      begin
           open my_ref for select * from logs;
           return my_ref;
      end;

      function monthlySaleActvities(
          employeeId in employees.eid%type) 
          return my_cursor is
          my_ref my_cursor;
      begin
          dbms_output.enable();
           open my_ref for    SELECT Employees.eid, name, to_char(pur_time, 'MON'), to_char(pur_time, 'YYYY'), 
                              COUNT(*), SUM(quantity), SUM(payment) 
                              FROM Employees 
                              JOIN Purchases ON Employees.eid = Purchases.eid 
                              GROUP BY Employees.eid,name, to_char(pur_time, 'MON'), to_char(pur_time, 'YYYY') 
                              HAVING Employees.eid = employeeId;
          return my_ref;
     end;
     
 /**
 *  procedure to add the new tuple to the employees tables
 *  by taking eid, name, telephone and email as input parameters
 */
 
     procedure add_employee(e_id IN employees.eid%type, e_name IN employees.name%type,
              e_telephone IN employees.telephone#%type, e_email IN employees.email%type) AS
     begin
      dbms_output.enable();
      insert into Employees (eid, name, telephone#, email) values (e_id, e_name, e_telephone, e_email);
      commit;
     dbms_output.put_line('New tuple is inserted into employees table.');
     -- To show exceptions occured when we insert eid which is alreay there in the table
     exception
     when dup_val_on_index then
        dbms_output.put_line('Error: Employee with eid:- ' || e_id || ' is already there in the Table.');
     when others then
        dbms_output.put_line('Error: ' || sqlerrm);
     end add_employee;


/**
 *  procedure for adding tuples to the Purchases table 
 *  by taking e_id, p_id, c_id, pur_qty, pur_unit_price input parameters
 *  and pur# is generated by seqpur# sequence
 *  payment is computed based on pur_qty * pur_unit_price, 
 *  saving is computed based on pur_qty * (v_orig_price - pur_unit_price) from 
 *  Products table, and pur_time should be generated by sysdate. 
 */

     procedure add_purchase(e_id in purchases.eid%type,
                            p_id in purchases.pid%type,
                            c_id in purchases.cid%type,
                            pur_qty in purchases.quantity%type, 
                            pur_unit_price in purchases.unit_price%type) is
     -- local declarations
     v_qoh products.qoh%type;
     v_orig_price products.orig_price%type;
     v_saving purchases.saving%type;
     v_payment purchases.payment%type;
     check_customer purchases.cid%type;
     check_employee purchases.eid%type;

     begin 
     dbms_output.enable();
     -- selecting the values of qoh and orig_price from products table to local declarations.
     select qoh, orig_price into v_qoh, v_orig_price from Products where pid = p_id;
     -- if qoh is less then purchase quantity showing the error.
     if v_qoh < pur_qty then
          dbms_output.put_line('Insufficient quantity in stock.');
          return;
     end if;
     -- calculating the payment and saving
     v_payment :=  pur_qty * pur_unit_price;
     v_saving := pur_qty * (v_orig_price - pur_unit_price);

      select count(*) into check_employee from employees where eid = e_id;
       if check_employee = 0 then
      -- customer doesn't exist, display error message
       dbms_output.put_line('Error: Employee ID ' || e_id || ' does not exist.');
       return;
     end if;

     select count(*) into check_customer from customers where cid = c_id;
       if check_customer = 0 then
      -- customer doesn't exist, display error message
       dbms_output.put_line('Error: Customer ID ' || c_id || ' does not exist.');
       return;
     end if;

     dbms_output.put_line('entered the add_purchase procedure...');
     -- inserting the tuple into the purchase table
     insert into purchases (pur#, eid, pid, cid, pur_time, quantity, unit_price, payment, saving)
     values (seqpur#.nextval, e_id, p_id, c_id, SYSDATE, pur_qty, pur_unit_price, v_payment , v_saving);

     dbms_output.put_line('Purchase successfully completed......');
     -- To show exceptions occured while inserting the tuple
     exception
     WHEN no_data_found THEN
      dbms_output.put_line('Product not found or Invalid product Id:  ' || p_id);
     when others then
        dbms_output.put_line('Error while adding purchase.....' || SQLERRM);
     end;

end;
/